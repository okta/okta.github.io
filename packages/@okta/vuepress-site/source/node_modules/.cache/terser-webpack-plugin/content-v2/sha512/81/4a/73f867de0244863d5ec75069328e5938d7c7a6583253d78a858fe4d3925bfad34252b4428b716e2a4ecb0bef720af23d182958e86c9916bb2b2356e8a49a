{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{178:function(e,t,a){\"use strict\";a.r(t);var o={props:[\"slot-key\"],mounted:function(){this.$nextTick(function(){this.$vuepress.$emit(\"AsyncMarkdownContentMounted\",this.slotKey)})}},i=a(5),r=Object(i.a)(o,function(){var e=this,t=e.$createElement,a=e._self._c||t;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.slotKey}},[a(\"h1\",{attrs:{id:\"validating-id-tokens\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#validating-id-tokens\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Validating ID Tokens\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"overview\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#overview\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Overview\")]),e._v(\" \"),a(\"p\",[e._v(\"If your client application requires authentication and would like to obtain information about the authenticated person, then it should use the OpenID Connect protocol to get an ID token.\")]),e._v(\" \"),a(\"p\",[e._v(\"OpenID Connect (OIDC) is an authentication protocol built on top of OAuth 2.0. With OAuth 2.0, a user can authenticate with an authorization server and get you an access token that authorizes access to some server resources. With OIDC, they can also give you a token called an ID token. The ID token contains information about a user and their authentication status. It can be used by your client both for authentication and as a store of information about that user. One OIDC flow can return both access and ID tokens.\")]),e._v(\" \"),a(\"p\",[e._v(\"We will now cover the terms used in this document, and an explanation of why you should use ID tokens.\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[e._v(\"If you'd like to jump straight to the local validation steps: \"),a(\"a\",{attrs:{href:\"#what-to-check-when-validating-an-id-token\"}},[e._v(\"What to Check When Validating an ID Token\")])]),e._v(\" \"),a(\"li\",[e._v(\"If you'd like to see how to validate a token directly with Okta: \"),a(\"a\",{attrs:{href:\"#validating-a-token-remotely-with-okta\"}},[e._v(\"Validating A Token Remotely With Okta\")])]),e._v(\" \"),a(\"li\",[e._v(\"If you want to see specifically how to accomplish this in your language of choice: \"),a(\"a\",{attrs:{href:\"#okta-libraries-to-help-you-verify-id-tokens\"}},[e._v(\"Okta Libraries to Help You Verify ID Tokens\")])])]),e._v(\" \"),a(\"p\",[e._v(\"A high-level overview of OpenID Connect can be found \"),a(\"router-link\",{attrs:{to:\"/authentication-guide/auth-overview/#openid-connect\"}},[e._v(\"here\")]),e._v(\".\")],1),e._v(\" \"),a(\"p\",[e._v(\"The ID tokens are in JSON Web Token (JWT) format, the specification for which can be found here: \"),a(\"a\",{attrs:{href:\"https://tools.ietf.org/html/rfc7519\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"https://tools.ietf.org/html/rfc7519\"),a(\"OutboundLink\")],1),e._v(\". They are signed using private JSON Web Keys (JWK), the specification for which you can find here: \"),a(\"a\",{attrs:{href:\"https://tools.ietf.org/html/rfc7517\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"https://tools.ietf.org/html/rfc7517\"),a(\"OutboundLink\")],1),e._v(\".\")]),e._v(\" \"),a(\"p\",[e._v(\"More information about Okta's ID tokens can be found in the \"),a(\"a\",{attrs:{href:\"/docs/api/resources/oidc#id-token\"}},[e._v(\"OIDC & OAuth 2.0 API Reference\")])]),e._v(\" \"),a(\"h2\",{attrs:{id:\"id-tokens-vs-access-tokens\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#id-tokens-vs-access-tokens\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" ID Tokens vs Access Tokens\")]),e._v(\" \"),a(\"p\",[e._v(\"The ID Token is a security token granted by the OpenID Provider that contains information about an End-User. This information tells your client application that the user is authenticated, and can also give you information like their username or locale.\")]),e._v(\" \"),a(\"p\",[e._v(\"You can pass an ID Token around different components of your client, and these components can use the ID Token to confirm that the user is authenticated and also to retrieve information about them.\")]),e._v(\" \"),a(\"p\",[e._v(\"Access tokens, on the other hand, are not intended to carry information about the user. They simply allow access to certain defined server resources. More discussion about when to use access tokens can be found in \"),a(\"a\",{attrs:{href:\"validating-access-tokens\"}},[e._v(\"Validating Access Tokens\")]),e._v(\".\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"what-to-check-when-validating-an-id-token\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#what-to-check-when-validating-an-id-token\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" What to Check When Validating an ID Token\")]),e._v(\" \"),a(\"p\",[e._v(\"The high-level overview of validating an ID token looks like this:\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[e._v(\"Retrieve and parse your Okta JSON Web Keys (JWK), which should be checked periodically and cached by your application.\")]),e._v(\" \"),a(\"li\",[e._v(\"Decode the ID token, which is in JSON Web Token format.\")]),e._v(\" \"),a(\"li\",[e._v(\"Verify the signature used to sign the ID token\")]),e._v(\" \"),a(\"li\",[e._v(\"Verify the claims found inside the ID token\")])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"retrieve-the-json-web-key-set\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#retrieve-the-json-web-key-set\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Retrieve The JSON Web Key Set\")]),e._v(\" \"),a(\"p\",[e._v(\"The JSON Web Key Set (JWKS) needs to be retrieved from your \"),a(\"a\",{attrs:{href:\"/authentication-guide/implementing-authentication/set-up-authz-server\"}},[e._v(\"Okta Authorization Server\")]),e._v(\", though your application should have it cached. Specifically, your Authorization Server's Metadata endpoint contains the \"),a(\"code\",[e._v(\"jwks_uri\")]),e._v(\", which you can use to get the JWKS.\")]),e._v(\" \"),a(\"blockquote\",[a(\"p\",[e._v(\"For more information about retrieving this metadata, see \"),a(\"a\",{attrs:{href:\"/docs/api/resources/oidc#well-knownoauth-authorization-server\"}},[e._v(\"Retrieve Authorization Server Metadata\")]),e._v(\".\")])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"decode-the-id-token\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#decode-the-id-token\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Decode the ID Token\")]),e._v(\" \"),a(\"p\",[e._v(\"You will have to decode the ID token, which is in JWT format. A list of libraries to help you do this can be found \"),a(\"a\",{attrs:{href:\"#okta-libraries-to-help-you-verify-id-tokens\"}},[e._v(\"below\")]),e._v(\".\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"verify-the-token-s-signature\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#verify-the-token-s-signature\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Verify the Token's Signature\")]),e._v(\" \"),a(\"p\",[e._v(\"You verify the ID token's signature by matching the key that was used to sign in with one of the keys you retrieved from your Okta Authorization Server's JWK endpoint. Specifically, each public key is identified by a \"),a(\"code\",[e._v(\"kid\")]),e._v(\" attribute, which corresponds with the \"),a(\"code\",[e._v(\"kid\")]),e._v(\" claim in the ID token header.\")]),e._v(\" \"),a(\"p\",[e._v(\"If the \"),a(\"code\",[e._v(\"kid\")]),e._v(\" claim does not match, it is possible that the signing keys have changed. Check the \"),a(\"code\",[e._v(\"jwks_uri\")]),e._v(\" value in the Authorization Server metadata and try retrieving the keys again from Okta.\")]),e._v(\" \"),a(\"p\",[e._v(\"Please note the following:\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[e._v(\"For security purposes, Okta automatically rotates keys used to sign the token.\")]),e._v(\" \"),a(\"li\",[e._v(\"The current key rotation schedule is four times a year. This schedule can change without notice.\")]),e._v(\" \"),a(\"li\",[e._v(\"In case of an emergency, Okta can rotate keys as needed.\")]),e._v(\" \"),a(\"li\",[e._v(\"Okta always publishes keys to the \"),a(\"code\",[e._v(\"jwks_uri\")]),e._v(\".\")]),e._v(\" \"),a(\"li\",[e._v(\"To save the network round trip, your app should cache the \"),a(\"code\",[e._v(\"jwks_uri\")]),e._v(\" response locally. The \"),a(\"a\",{attrs:{href:\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"standard HTTP caching headers\"),a(\"OutboundLink\")],1),e._v(\" are used and should be respected.\")]),e._v(\" \"),a(\"li\",[e._v(\"The administrator can switch the Authorization Server key rotation mode by updating the Authorization Server's \"),a(\"code\",[e._v(\"rotationMode\")]),e._v(\" property. For more information see the API Reference: \"),a(\"a\",{attrs:{href:\"/docs/api/resources/authorization-servers#credentials-object\"}},[e._v(\"Authorization Server Credentials Signing Object\")]),e._v(\".\")])]),e._v(\" \"),a(\"blockquote\",[a(\"p\",[e._v(\"Keys used to sign tokens automatically rotate and should always be resolved dynamically against the published JWKS. Your app might fail if you hardcode public keys in your applications. Be sure to include key rollover in your implementation.\")])]),e._v(\" \"),a(\"blockquote\",[a(\"p\",[e._v(\"If your application cannot retrieve keys dynamically, the administrator can disable the automatic key rotation in the administrator UI, \"),a(\"a\",{attrs:{href:\"/docs/api/resources/apps#generate-new-application-key-credential\"}},[e._v(\"generate a key credential\")]),e._v(\" and \"),a(\"a\",{attrs:{href:\"/docs/api/resources/apps#update-key-credential-for-application\"}},[e._v(\"update the application\")]),e._v(\" to use it for signing.\")])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"verify-the-claims\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#verify-the-claims\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Verify the Claims\")]),e._v(\" \"),a(\"p\",[e._v(\"You should verify the following:\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[e._v(\"The \"),a(\"code\",[e._v(\"iss\")]),e._v(\" (issuer) claim matches the identifier of your Okta Authorization Server.\")]),e._v(\" \"),a(\"li\",[e._v(\"The \"),a(\"code\",[e._v(\"aud\")]),e._v(\" (audience) claim should match the Client ID that you used to request the ID Token. This will be the Client ID for the Application you created in Okta.\")]),e._v(\" \"),a(\"li\",[e._v(\"The \"),a(\"code\",[e._v(\"iat\")]),e._v(\" (issued at time) claim indicates when this ID token was issued, expressed in Unix time.\")]),e._v(\" \"),a(\"li\",[e._v(\"The \"),a(\"code\",[e._v(\"exp\")]),e._v(\" (expiry time) claim is the time at which this token will expire., expressed in Unix time. You should make sure that this time has not already passed.\")]),e._v(\" \"),a(\"li\",[e._v(\"The \"),a(\"code\",[e._v(\"nonce\")]),e._v(\" claim value should match whatever was passed when you requested the ID token.\")])]),e._v(\" \"),a(\"h2\",{attrs:{id:\"validating-a-token-remotely-with-okta\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#validating-a-token-remotely-with-okta\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Validating A Token Remotely With Okta\")]),e._v(\" \"),a(\"p\",[e._v(\"Alternatively, you can also validate an ID Token using the Token Introspection endpoint: \"),a(\"a\",{attrs:{href:\"/docs/api/resources/oidc#introspect\"}},[e._v(\"Introspection Request\")]),e._v(\". This endpoint takes your token as a URL query and returns back a JSON response with a boolean \"),a(\"code\",[e._v(\"active\")]),e._v(\" property. If \"),a(\"code\",[e._v(\"active\")]),e._v(\" is \"),a(\"code\",[e._v(\"true\")]),e._v(\" then further information about the token is returned as well.\")]),e._v(\" \"),a(\"p\",[e._v(\"This incurs a network request which is slower to do verification, but can be used when you want to guarantee that the access token hasn't been revoked.\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"okta-libraries-to-help-you-verify-id-tokens\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#okta-libraries-to-help-you-verify-id-tokens\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Okta Libraries to Help You Verify ID Tokens\")]),e._v(\" \"),a(\"p\",[e._v(\"The Okta JWT Verifier is available for the following languages:\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[a(\"a\",{attrs:{href:\"https://github.com/okta/okta-jwt-verifier-golang\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"Golang\"),a(\"OutboundLink\")],1)]),e._v(\" \"),a(\"li\",[a(\"a\",{attrs:{href:\"https://github.com/okta/okta-jwt-verifier-java\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"Java\"),a(\"OutboundLink\")],1)]),e._v(\" \"),a(\"li\",[a(\"a\",{attrs:{href:\"https://github.com/okta/okta-oidc-js/tree/master/packages/jwt-verifier\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"Node.js\"),a(\"OutboundLink\")],1)]),e._v(\" \"),a(\"li\",[a(\"a\",{attrs:{href:\"https://github.com/okta/okta-jwt-verifier-php\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"PHP\"),a(\"OutboundLink\")],1)])]),e._v(\" \"),a(\"p\",[e._v(\"Don't see the language you're working in? Get in touch: \"),a(\"a\",{attrs:{href:\"mailto:developers@okta.com\"}},[e._v(\"developers@okta.com\")])])])},[],!1,null,null,null);r.options.__file=\"index.md\";t.default=r.exports}}]);","extractedComments":[]}