{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[100],{210:function(t,a,e){\"use strict\";e.r(a);var s={props:[\"slot-key\"],mounted:function(){this.$nextTick(function(){this.$vuepress.$emit(\"AsyncMarkdownContentMounted\",this.slotKey)})}},n=e(5),o=Object(n.a)(s,function(){var t=this,a=t.$createElement,e=t._self._c||a;return e(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.slotKey}},[e(\"div\",{staticStyle:{\"font-size\":\"0.9em\",\"margin-bottom\":\"-20px\"}},[e(\"a\",{attrs:{href:\"/books/api-security/sanitizing/\"}},[t._v(\"‚Üê Sanitizing Data\")])]),t._v(\" \"),e(\"h2\",{attrs:{id:\"accept-known-good-sanitizing-accept-good\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#accept-known-good-sanitizing-accept-good\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" Accept Known Good {#sanitizing-accept-good}\")]),t._v(\" \"),e(\"p\",[t._v(\"The known good strategy is often the easiest and most foolproof of the given options. With this approach each input is validated against an expected type and format:\")]),t._v(\" \"),e(\"ul\",[e(\"li\",[t._v(\"Data type, (Integers are Integers, booleans are booleans, etc)\")]),t._v(\" \"),e(\"li\",[t._v(\"Numeric values fall within an expected range (for example: a person's age is always greater than 0 and less than 150)\")]),t._v(\" \"),e(\"li\",[t._v(\"Field length is checked\")]),t._v(\" \"),e(\"li\",[t._v(\"Specially formatted string fields such as zipcode, phone number, and social security number are valid\")])]),t._v(\" \"),e(\"p\",[t._v(\"Most web frameworks have some type of declarative support to validate input fields built in. For example,  in the Node.js world you can use the popular \"),e(\"code\",[t._v(\"validator\")]),t._v(\" package to validate different types of input:\")]),t._v(\" \"),e(\"div\",{staticClass:\"language-js extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-js\"}},[e(\"code\",[e(\"span\",{attrs:{class:\"token keyword\"}},[t._v(\"import\")]),t._v(\" validator \"),e(\"span\",{attrs:{class:\"token keyword\"}},[t._v(\"from\")]),t._v(\" \"),e(\"span\",{attrs:{class:\"token string\"}},[t._v(\"'validator'\")]),e(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\nvalidator\"),e(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\".\")]),e(\"span\",{attrs:{class:\"token function\"}},[t._v(\"isEmail\")]),e(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),e(\"span\",{attrs:{class:\"token string\"}},[t._v(\"'foobar@example.com'\")]),e(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\")\")]),e(\"span\",{attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\")])])])])},[],!1,null,null,null);o.options.__file=\"index.md\";a.default=o.exports}}]);","extractedComments":[]}