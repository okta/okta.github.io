---
layout: blog_post
title: "UI Development in a Microservices World"
author: mraible
description: "Adopting a microservice architecture for your backend can be useful to scale teams of developers. But what about the UI? Learn about micro frontends and more!"
tags: [microservices, micro frontends, ui, ux, web development]
tweets:
image:
---
:page-liquid:

Microservices have become a very popular way of scaling teams in large companies. Using a microservices architecture allows you to build and deploy services independently. This gives development teams autonomy, enthusiasm, and a passion for the work. This happens because they feel a sense of control over their own destiny.

Let me start with a story about my time at LinkedIn. In early 2008, they asked me to do an analysis of Rails versus Grails and tell them which one they should use. They had an app written in both frameworks and the CTO didn't want to support both. Both platforms allowed developers to iterate quickly and turbo-charge their productivity.

My Conclusion: **Allow Both**

_Why?_ You might ask.

If you have talented developers that can whip out kick-ass code with either platform, pay them and pay them well. Passion is the most important part of any job. If developers are passionate about the application they're developing and the language they're using (notice language is secondary) - they can do great things.

This is one of the beautiful aspects of a microservices architecture. If it's implemented right, developers can choose the language or framework they're most passionate about. As long as they have an API that can be aggregated at a gateway layer, it shouldn't matter.

On the other hand, adopting a microservices architecture moves the complexity to the network. Distributed systems are harder to deploy, maintain, and monitor. Continuous deployment is essential, as are good monitoring tools.

What about the UI that talks to a microservice architecture? For the most part, many of us have developed monolithic UI's that communicate with the microservice back-end. Before I jump into solutions for splitting up front ends that talk to microservices, let's take a look at a brief history of web frameworks.

== A Brief History of Web Frameworks

Web frameworks have been around for more than 20 years. Dynamic websites started with CGI and traversed to servlets, ASP, and PHP in the late 90s. In the early 2000, web frameworks became more and more popular (especially in the Java ecosystem).

image::{% asset_path 'blog/micro-frontends/history-of-web-frameworks-timeline.png' %}[alt=History of Web Frameworks Timeline,align=center]

TIP: The timeline above can be modified https://github.com/mraible/history-of-web-frameworks-timeline[via GitHub].

Struts 1.0 came out in June 2001. ASP.NET 1.0. O was released in early 2002. Java web Frameworks exploded over the next couple years and people laughed at the Java community for having so many frameworks. In 2006, web frameworks change greatly with the release of Ruby on Rails, jQuery, and Dojo (one of the first JavaScript MVC frameworks). This started the JavaScript Renaissance which has lasted many years, until today.

Now people make fun of JavaScript for having so many frameworks. However, in my opinion, the dust has settled and there's three main players: Angular, React, and Vue.

It's true there might be future web framework wars but I think we can agree that there's not a new JavaScript framework every week like many people joke there is.

The first batch of web frameworks in the early 2000s leveraged MVC and server-side rendering. Then along came a Ajax, single-page applications, and the mobile revolution. Because single-page applications can be distributed in a single bundle, they became popular for mobile apps as well. You're probably heard of Ionic and React Native; both frameworks allow web developers to use their existing skills to develop native mobile apps.

Both server-side rendering and single-page apps have their place in the world. In fact, server-side rendering has become a recommended practice for the initial load of SPAs. Generating static websites has become populate took, as have CDNs (content delivery networks), and front end performance optimization.

This brings us to today, where it's commonplace to mix and match your MVC framework with SPAs for more dynamic functionality. If you're going to develop Photoshop as a webapp, you're not going to want to use server-side rendering. You're going to want that as a SPA. Developing something like Wikipedia makes no sense for a SPA, but works well with MVC or with a static site generator.

== The Microservices Explosion ðŸ’¥

The term microservices was first coined in 2007. Many call it Service Oriented Architecture (SOA) reincarnated, and it kinda is.

> If you're not familiar with SOA, I suggest you read https://www.okta.com/security-blog/2019/07/microservices-vs-soaâ€”whats-the-difference[Microservices vs. SOA -- What's the Difference?] from the Okta Security blog.

Microservices blew up in popularity when James Lewis and Martin Fowler published the article "https://martinfowler.com/articles/microservices.html[Microservices]". Adrian Cockcroft was a big part of this movement as well. He worked at Netflix at the time and helped pioneer microservices at scale. Adrian is now VP of Cloud Architecture Strategy at AWS.

This all happened around the same year (2014) that Spring Boot was https://spring.io/blog/2014/04/01/spring-boot-1-0-ga-released[first released]. Spring Cloud 1.0 was https://spring.io/blog/2015/03/04/spring-cloud-1-0-0-available-now[released] a year later in March 2015, bringing many of Netflix's components to the Spring and Java community.

There are many ways to implement microservice architectures. Spring Boot, Spring Cloud, and MicroProfile are some of the most popular ways in the Java ecosystem. Micronaut and Quarkus are two relatively newcomers to the space; proving there's a lot of interest from developers and market share to be had from vendors. Yes, both are open source projects, but they're largely sponsored by software companies (OCI and IBM, respectively).

// todo: anything for microservices in other communities

Microservices are most successful when they're used to scale developers and leverage continuous deployment. They give developers the ability to be autonomous as a team and go from idea to production without requiring help from other teams. A two-pizza team will often contain product people (for ideas), backend folks (including DBAs), UI developers, and DevOps people (that deploy and manage production).

If your organization doesn't allow teams to be formed this way, microservices are probably not for you.

[quote, M. Conway]
____
organizations which design systems ... are constrained to produce designs which are copies of the communication structures of these organizations.
____

If your organization has DBAs, backend developers, UI developers, and DevOps people separated by function, you should change your communication structures before adopting microservices. Organize your teams around products, then think about adopting a microservices architecture.

Once you have communication structures flowing around products and teams owning everything from idea to production monitoring, you can adopt microservices. Until then, a monolith will probably work just fine.

++++
<div style="max-width: 500px; margin: 0 auto 1.25rem">
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">(Apparently still) unpopular opinion - monoliths are okay for many, many applications. Not everything needs to, or should, be <a href="https://twitter.com/hashtag/microservices?src=hash&amp;ref_src=twsrc%5Etfw">#microservices</a>. There is a spectrum of applications in every company.</p>&mdash; Fintan Ryan (@fintanr) <a href="https://twitter.com/fintanr/status/1156136718581534720?ref_src=twsrc%5Etfw">July 30, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</div>
++++

Building a monolith UI on top of a microservice architecture can work if your teams agree on the same web framework and develop everything as components. One of the beauties of microservices is you can use different languages and frameworks to develop them. As long as they provide data at a particular endpoint.

Is it possible to use separate frameworks on the front end too? Keep reading.

== UI Development in a Microservices World

I've worked on a few projects that used a microservices architecture. Even though the backend services were split up into separate services, the UI was often a monolith. It used a single web framework and made requests to the backend API gateway. The API gateway served as an aggregation layer that exposed all the various servers at the same base URL.

=== State of the Art in Java + JavaScript

This works well and is currently state of the art in the Java space, as evidenced by JHipster. If you haven't heard of JHipster, it's a platform for generating Spring Boot monoliths and microservices with a JavaScript frontend. Current frontend options include Angular, React, and Vue.

When you generate a microservices architecture with JHipster, it's composed of a gateway and 1-n microservices. The microservice apps do not have a front-end, they just have REST APIs and persist data to their own database. The gateway serves as the aggregation layer. This is also where the UI code resides. That's right, even though JHipster supports microservices, it only does it on the backend.

Below is a video showing where the frontend code resides in a JHipster-generated microservices architecture.

++++
<div style="text-align: center; margin-bottom: 1.25rem">
<iframe width="700" height="394" style="max-width: 100%" src="https://www.youtube.com/embed/-QCuWgLQmdg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
++++

JHipster 6 generates a frontend monolith for microservices by default. This works because it doesn't currently allow multiple frameworks on its gateway UI. It also leverages lazy-loading for Angular, React, and Vue to make the initial download and render fast. It could be faster with server-side rendering support, but I digress.

// The gateway UI is the aggregation layer and you'll need if you want to adopt micro frontends.

== Micro Frontends to the Rescue!ï¸âš¡ï¸

Recently, there's been a lot of activity around Micro Frontends. Similar to microservices, "https://martinfowler.com/articles/micro-frontends.html[Micro Frontends]" was published on Martin Fowler's blog. It's written by https://twitter.com/thecamjackson[Cam Jackson] and includes a number of integration approaches. He notes that ThoughtWorks Radar has https://www.thoughtworks.com/radar/techniques/micro-frontends[moved micro frontends from trial to adopt over the last few years]:

- November 2016: Assess
- November 2017: Trail
- April 2019: Adopt

Jackson notes that ThoughtWorks has witnessed some key benefits from micro frontends:

* Smaller, more cohesive and maintainable codebases
* More scalable organizations with decoupled, autonomous teams
* The ability to upgrade, update, or even rewrite parts of the frontend in a more incremental fashion than was previously possible

https://twitter.com/naltatis[Michael Geers] is another micro frontends expert. He created https://micro-frontends.org/[micro-frontends.org] way back in March 2017. As his https://github.com/neuland/micro-frontends/commit/138fb9531bf48617778b6520a1c0ac92b7d2c0d7[first commit] mentions, the primary motivation for adopting micro frontends is to help scale developers.

> frontend integration recipes for composing a website with multiple teams

His website has a concise description of the idea behind micro frontends:

> The idea behind Micro Frontends is to think about a website or web app as a composition of features which are owned by independent teams. Each team has a distinct area of business or mission it cares about and specialises in. A team is cross functional and develops its features end-to-end, from database to user interface.

=== Techniques and Micro Frontend Frameworks

There are several techniques you can use to implement micro frontends. One of my favorite examples I learned about from listening to https://www.case-podcast.org/22-micro-frontends-with-gustaf-nilsson-kotte[Micro Frontends with Gustaf Nilsson Kotte] on the Conversations about Software Engineering podcast. https://twitter.com/gustaf_nk[Gustaf Nilsson Kotte] is developer at Jayway and he describes how IKEA has leveraged micro frontends.

Michael Geers's micro-frontends.org site explains an architecture similar to Gustaf's, except it uses SSI and server-side rendering with Nginx.

image::{% asset_path 'blog/micro-frontends/micro-frontend-verticals.png' %}[alt=Michael Greer: Organization in Verticals,width=800,align=center]

Cam Jackson's article has many more integration approaches, including server-side rendering, build-time integration, and run-time integration with iframes, JavaScript, and web components.

image::{% asset_path 'blog/micro-frontends/micro-frontend-ssi.png' %}[alt=Cam Jackson: Each of these servers can be built and deployed to independently,width=700,align=center]

All three techniques seem to involve:

* Web components as the target output
* Custom elements to create web components
* DOM Events to communicate between frontends
* Server-side rendering and SSI (server-side includes) or ESI (edge-side includes)
* CDNs and cache busting as a deployment mechanism

There's also a couple frameworks you can use to implement micro frontends:

* **https://www.mosaic9.org/[Project Mosaic]**: Mosaic is a set of services, libraries together with a specification that defines how its components interact with each other, to support a microservice style architecture for large scale websites.
* **https://single-spa.js.org/[Single-spa]**: A JavaScript framework for front-end microservices.

Both definitions are taken from their respective websites. Mosaic seems like Spring Cloud for the UI, with lots of sub-projects. It's sponsored by https://zalando.com/[Zalando], which is "an e-commerce company into a multi-service platform for fashion."

Spring-spa has a neat https://single-spa.surge.sh/[live demo].

==== What are Developers Using to Implement Micro Frontends?

I did a poll on Twitter last week and it seems to be the most popular technique/framework among my followers.

++++
<div style="max-width: 500px; margin: 0 auto 1.25rem">
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Have you implemented Micro Frontends (as described in <a href="https://twitter.com/naltatis?ref_src=twsrc%5Etfw">@naltatis</a>&#39;s <a href="https://t.co/UuPCXYQMuv">https://t.co/UuPCXYQMuv</a> and <a href="https://twitter.com/thecamjackson?ref_src=twsrc%5Etfw">@thecamjackson</a>&#39;s <a href="https://t.co/w4yKXSd0Rj">https://t.co/w4yKXSd0Rj</a>)? <br><br>If so, how have you done it?</p>&mdash; Matt Raible (@mraible) <a href="https://twitter.com/mraible/status/1156263974649778176?ref_src=twsrc%5Etfw">July 30, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</div>
++++

There were only 13 votes. I usually get around 200 responses when I do polls on Twitter. This indicates (to me) that micro frontends is still pretty bleeding edge.

=== Real Developer Stories

The IKEA implementation uses a combination of static pages, SPAs, and ESI for their architecture. IKEA has over 200,000 employees; I'm not sure how many developers work there. They have ESIs for CSS and individual components, and leverage https://github.com/gustafnk/h-include[h-include] for doing includes on the frontend. The cool thing about h-include is it allows them to render components of their pages just-in-time. If the component is below-the-fold, it's not rendered. When the user scrolls to bring it into view, it invokes rendering. Lazy-loading FTW!

Spotify is another company that's https://medium.com/@tomsoderlund/micro-frontends-a-microservice-approach-to-front-end-web-development-f325ebdadc16[rumored to have implemented micro frontends]. They only have ~2000 employees, but they've been known to be a progressive technology company. Other examples include Klarna, Zalando, Upwork, and Allegro, and HelloFresh.

I https://twitter.com/mraible/status/1156641005799530496[asked the internet] for more developer stories and received a good real-world story from https://twitter.com/atomfrede[Frederik Hahne]. Frederik is a fellow JHipster committer, so I call him a friend.

Frederik was gracious enough to answer my questions and give some insight about why and how they've adapted microfrontends for their B2B integration platform https://www.wescale.com/[wescale].

**How many developers does your company have?**

Overall we are now 40 (~6 scrum team) developers working on different parts of the platform or related products/services. When we started in 2014 to work on the new platform we were one team of 4 developers.

**Why did you adopt a micro frontend architecture?**

- Teams can work autonomously on different parts of the UI (the most important IMHO, as the ng1 app had a lot of problems, one team changes a bit of style/component it breaks for another)
- Teams can release independently different parts of the UI (with ng1 monolith we couldn't release when one team was not ready to release their changes)
- Teams can use diverse technologies for different parts of the UI (ng1 was ok, ngX way to heavy. We wanted the teams to use what they are most confident with)
- Teams can test more focused and effectively different parts of the UI

**What technique(s) / frameworks(s) did you use?**

We use "Server Side Includes + Http Streaming". We have build on Zalando's Project Mosaic and use Tailor as a layout service with a UI gateway (aka reverse proxy + auth etc).

**Is it a better or worse developer experience than before? Why?**

It is much better now, but we needed a custom app to provide, as we call it a development shell (sidemenu, header bar with some stub functions, and faking authentication for example). Having a smaller UI bundle and better tooling helped to decrease the turn around times when developing the UI a lot. So basically, UI development is now fun again!

**What were/are the biggest pain points?**

We didn't want to have a big bang release and the ng1 app was already in production so we needed to make the ng1 app a fragment such it would work like microfrontend, so we could migrate parts to a new ui if required. We have replaced some parts, but a lot of the old ui is still in production as the value didn't exceed the effort to replace it.

Another pain point was (and is still) the UI consistency. We have one designer who defines how components should look and work. We have a custom UI library based on Bootstrap but still developers can do what they want (as they are no necessarily e.g. ready to use Vue components).

== Learn More Micro Frontends and Microservices

This blog post describes what micro frontends are, how they're implemented, and gives some real-world examples of companies using them.

UI development in a microservices world has two main options:

* A monolith frontend that uses the same framework, components, and lazy-loading
* A micro frontend architecture that allows any framework, leveraging web components

They both seem pretty nice to me. Similar to microservices, a micro frontend will likely require more initial infrastructure. It'll also likely be harder to debug than a monolith.

That said, if you have teams that are passionate about a particular framework, it might be just what you're looking for. The Grails and Rails teams I worked with at LinkedIn were _very_ passionate about their framework choices.

Wouldn't you like to be an enabler of developer productivity and passion? I sure would!

If you're interested in learning more about micro frontends, I found several resources in my research:

* https://micro-frontends.org/[Micro Frontends] by Michael Greer
* https://martinfowler.com/articles/micro-frontends.html[Micro Frontends] by Cam Jackson
* https://dev.to/parkroolucas/micro-frontends-a-deep-dive-into-the-latest-industry-trend-3i7a[Micro Frontends: a deep dive into the latest industry trend] by Lucas Chen
* https://medium.com/javascript-in-plain-english/microfrontends-bringing-javascript-frameworks-together-react-angular-vue-etc-5d401cb0072b[Microfrontends â€” bringing JavaScript frameworks together (React, Angular, Vue etc)] by Chris Kitson

If you're interested in microservices, we have a number of good posts on this blog:

* link:/blog/2019/05/22/java-microservices-spring-boot-spring-cloud[Java Microservices with Spring Boot and Spring Cloud]
* link:/blog/2019/03/21/build-secure-microservices-with-aspnet-core[Build Secure Microservices with AWS Lambda and ASP.NET Core]
* link:/blog/2019/06/26/build-secure-microservices-in-php[Build Secure Microservices in PHP]

Like what you read here? Follow my team https://twitter.com/oktadev[@oktadev] or subscribe to our https://www.youtube.com/c/oktadev[channel on YouTube]. Until next time, stay awesome!

image::{% asset_path 'blog/micro-frontends/you-dont-need-permission.jpg' %}[alt=You don't need permission to be awesome,width=500,align=center]
