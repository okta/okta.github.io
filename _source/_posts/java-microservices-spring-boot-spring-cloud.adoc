---
layout: blog_post
title: "Java Microservices with Spring Boot and Spring Cloud"
author: mraible
description: "This tutorial shows you how to build a microservices architecture with Spring Boot 2.1 and Spring Cloud Greenwich."
tags: [java, microservices, spring boot, spring cloud, spring cloud config, jhipster]
tweets:
image: blog/java-microservices/tbd.png
---
:page-liquid:

Java is a great language for developing a microservice architecture with. In fact, some of the biggest names in our industry use it. Have you ever heard of Netflix, Amazon, or Google. What about eBay, Twitter, and LinkedIn? Yes, major companies handling incredible traffic are doing it with Java.

Implementing a microservices architecture in Java isn't for everyone. For that matter, implementing microservices in general isn't often needed. Most companies do it to scale their people, not their systems. If you're going to scale your people, hiring Java developers is one of the best ways to do it. After all, there's more developers fluent in Java than most other languages - though JavaScript seems to be catching up quickly!

The Java ecosystem has some well-established patterns for developing microservice architectures. If you're familiar with Spring, you'll feel right at home developing with Spring Boot and Spring Cloud. Since that's one of the quickest ways to get started, I figured I'd walk you through a quick tutorial.

== Create Java Microservices with Spring Cloud and Spring Boot

In most of my tutorials, I walk you through building everything from scratch. Today I'd like to take a different approach and walk you through a pre-built example. Hopefully this will be a bit shorter and easier to understand.

You can start by cloning my https://github.com/oktadeveloper/java-microservices-examples[java-microservices-examples] repository.

[source,shell]
----
git clone https://github.com/oktadeveloper/java-microservices-examples.git
----

In the `spring-boot+cloud` directory, there are three projects:

* **discovery-service**: a Netflix Eureka server, used for service discovery.
* **car-service**: a simple Car Service that uses Spring Data REST to serve up a REST API of cars.
* **api-gateway**: an API gateway that has a `/cool-cars` endpoint that talks to the `car-service` and filters out cars that aren't cool (IMO).

I created all of these applications using https://start.spring.io[start.spring.io's] REST API and https://httpie.org[HTTPie].

[source,shell]
----
http https://start.spring.io/starter.zip javaVersion==11 \
  artifactId==discovery-service name==eureka-service \
  dependencies==cloud-eureka-server baseDir==discovery-service | tar -xzvf -

http https://start.spring.io/starter.zip \
  artifactId==car-service name==car-service baseDir==car-service \
  dependencies==actuator,cloud-eureka,data-jpa,h2,data-rest,web,devtools,lombok | tar -xzvf -

http https://start.spring.io/starter.zip \
  artifactId==api-gateway name==api-gateway baseDir==api-gateway \
  dependencies==cloud-eureka,cloud-feign,data-rest,web,cloud-hystrix,lombok | tar -xzvf -
----

=== Spring Microservices with Java 11+

To make the `discovery-service` run on Java 11, I had to add a dependency on JAXB.

[source,xml]
----
<dependency>
    <groupId>org.glassfish.jaxb</groupId>
    <artifactId>jaxb-runtime</artifactId>
</dependency>
----

The other two applications worked fine out-of-the-box on Java 11 with no changes in dependencies.

== Java Service Discovery with Netflix Eureka

The `discovery-service` is configured the same as you would most Eureka servers. It as an `@EnableEurekaServer` annotation on its main class and properties that set its port and turn off discovery.

[source,properties]
----
server.port=8761
eureka.client.register-with-eureka=false
----

The `car-service` and `api-gateway` projects are configured in a similar fashion. Both have a unique name defined and `car-service` is configured to run on port `8090` so it doesn't conflict with `8080`.

[source,properties]
.car-service/src/main/resources/application.properties
----
server.port=8090
spring.application.name=car-service
----

[source,properties]
.car-service/src/main/resources/application.properties
----
spring.application.name=api-gatway
----

The main class in both projects is annotated with `@EnableDiscoveryClient`.

== Build a Java Microservice with Spring Data REST

The `car-service` provides a REST API that lets you CRUD cars. It creates a default set of cars when the application loads using an `ApplicationRunner` bean.

[source,java]
.car-service/src/main/java/com/example/carservice/CarServiceApplication.java
----
package com.example.carservice;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import org.springframework.boot.ApplicationRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.context.annotation.Bean;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.rest.core.annotation.RepositoryRestResource;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import java.util.stream.Stream;

@EnableDiscoveryClient
@SpringBootApplication
public class CarServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(CarServiceApplication.class, args);
    }

    @Bean
    ApplicationRunner init(CarRepository repository) {
        return args -> {
            Stream.of("Ferrari", "Jaguar", "Porsche", "Lamborghini", "Bugatti",
                    "AMC Gremlin", "Triumph Stag", "Ford Pinto", "Yugo GV").forEach(name -> {
                repository.save(new Car(name));
            });
            repository.findAll().forEach(System.out::println);
        };
    }
}

@Data
@NoArgsConstructor
@Entity
class Car {

    public Car(String name) {
        this.name = name;
    }

    @Id
    @GeneratedValue
    private Long id;

    @NonNull
    private String name;
}

@RepositoryRestResource
interface CarRepository extends JpaRepository<Car, Long> {
}
----

=== Spring Cloud + Feign and Hystrix in an API Gateway

https://github.com/OpenFeign/feign[Feign] makes writing Java HTTP clients easier. Spring Cloud makes it possible to create a Feign client with just a few lines of code. https://github.com/Netflix/Hystrix[Hystrix] makes it possible to add failover capabilities to your Feign clients so they're more resilient.

The `api-gateway` uses Feign and Hystrix to talk to the downstream `car-service` and failover to a `fallback()` method if it's unavailable. It also exposes a `/cool-cars` endpoint that filters out cars you might not want to drive.

[source,java]
.api-gateway/src/main/java/com/example/apigateway/ApiGatewayApplication.java
----
package com.example.apigateway;

import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
import lombok.Data;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.hateoas.Resources;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.ArrayList;
import java.util.Collection;
import java.util.stream.Collectors;

@EnableFeignClients
@EnableCircuitBreaker
@EnableDiscoveryClient
@EnableZuulProxy
@SpringBootApplication
public class ApiGatewayApplication {

    public static void main(String[] args) {
        SpringApplication.run(ApiGatewayApplication.class, args);
    }

}

@Data
class Car {
    private String name;
}

@FeignClient("car-service")
interface CarClient {

    @GetMapping("/cars")
    @CrossOrigin
    Resources<Car> readCars();
}

@RestController
class CoolCarController {

    private final CarClient carClient;

    public CoolCarController(CarClient carClient) {
        this.carClient = carClient;
    }

    private Collection<Car> fallback() {
        return new ArrayList<>();
    }

    @GetMapping("/cool-cars")
    @CrossOrigin
    @HystrixCommand(fallbackMethod = "fallback")
    public Collection<Car> goodCars() {
        return carClient.readCars()
                .getContent()
                .stream()
                .filter(this::isCool)
                .collect(Collectors.toList());
    }

    private boolean isCool(Car car) {
        return !car.getName().equals("AMC Gremlin") &&
                !car.getName().equals("Triumph Stag") &&
                !car.getName().equals("Ford Pinto") &&
                !car.getName().equals("Yugo GV");
    }
}
----

== Run a Java Microservices Architecture

If you run all of these services with `./mvnw` in separate terminal windows, you can navigate to `http://localhost:8761` and see they've all registered with Eureka.

image::{% asset_path 'blog/java-microservices/eureka-server.png' %}[alt=Eureka Server,width=800,align=center]

If you navigate to `http://localhost:8080/cool-bars` in your browser, you'll be redirected to Okta. What the?

== Secure Java Microservices with OAuth 2.0 and OIDC

I've already configured security of this microservices architecture using OAuth 2.0 and OIDC. What's the difference between the two? OIDC is an extension to OAuth 2.0 that provides identity. It also provides discovery so all the different OAuth 2.0 endpoints can be discovered from a single URL (called an `issuer`).

How did I configure security for all these microservices? I'm glad you asked!

I added Oktaâ€™s Spring Boot starter to the `pom.xml` in `api-gateway` and `car-service`:

[source,xml]
----
<dependency>
    <groupId>com.okta.spring</groupId>
    <artifactId>okta-spring-boot-starter</artifactId>
    <version>1.2.0</version>
</dependency>
----

Then I created a new OIDC app in Okta, configured with authorization code flow. You'll need to complete the following steps if you want to see everything in action.

=== Create a Web Application in Okta

Log in to your Okta Developer account (or [sign up](https://developer.okta.com/signup/) if you donâ€™t have an account).

1. From the **Applications** page, choose **Add Application**.
2. On the Create New Application page, select **Web**.
3. Give your app a memorable name, add `http://localhost:8080/login/oauth2/code/okta` as a Login redirect URI, select **Refresh Token** (in addition to **Authorization Code**), and click **Done**.

Copy the issuer (found under **API** > **Authorization Servers**), client ID, and client secret into `application.properties` for both projects.

[source,properties]
----
okta.oauth2.issuer=$issuer
okta.oauth2.client-id=$clientId
okta.oauth2.client-secret=$clientSecret
----

The Java code in the section below already exists, but I figured I'd explain it so you know what's going on.

=== Configure Spring Security for OAuth 2.0 Login and Resource Server

In `ApiGatewayApplication.java`, I added Spring Security configuration to enable OAuth 2.0 login and enable the gateway as a resource server.

[source,java]
----
@Configuration
static class OktaOAuth2WebSecurityConfigurerAdapter extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // @formatter:off
        http
            .authorizeRequests().anyRequest().authenticated()
                .and()
            .oauth2Login()
                .and()
            .oauth2ResourceServer().jwt();
        // @formatter:on
    }
}
----

The resource server configuration is not used in this example, but I added in case you wanted to hook up a mobile app or SPA to this gateway. If you're using a SPA, you'll also need to add a bean to configure CORS.

[source,java]
----
@Bean
public FilterRegistrationBean<CorsFilter> simpleCorsFilter() {
    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    CorsConfiguration config = new CorsConfiguration();
    config.setAllowCredentials(true);
    config.setAllowedOrigins(Collections.singletonList("*"));
    config.setAllowedMethods(Collections.singletonList("*"));
    config.setAllowedHeaders(Collections.singletonList("*"));
    source.registerCorsConfiguration("/**", config);
    FilterRegistrationBean<CorsFilter> bean = new FilterRegistrationBean<>(new CorsFilter(source));
    bean.setOrder(Ordered.HIGHEST_PRECEDENCE);
    return bean;
}
----

NOTE: If you do add a CORS filter like this one, I recommend you change the origins, methods, and headers to be more specific, increasing security.

The `CarServiceApplication.java` is only configured as a resource server since it's not expected to be accessed directly.

[source,java]
----
@Configuration
static class OktaOAuth2WebSecurityConfigurerAdapter extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // @formatter:off
        http
            .authorizeRequests().anyRequest().authenticated()
                .and()
            .oauth2ResourceServer().jwt();
        // @formatter:on
    }
}
----

To make it possible for the API gateway to access the Car Service, I created a `UserFeignClientInterceptor.java` in the API gateway project.

[source,java]
.api-gateway/src/main/java/com/example/apigateway/UserFeignClientInterceptor.java
----
package com.example.apigateway;

import feign.RequestInterceptor;
import feign.RequestTemplate;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.oauth2.client.OAuth2AuthorizedClient;
import org.springframework.security.oauth2.client.OAuth2AuthorizedClientService;
import org.springframework.security.oauth2.client.authentication.OAuth2AuthenticationToken;
import org.springframework.security.oauth2.core.OAuth2AccessToken;
import org.springframework.stereotype.Component;

@Component
public class UserFeignClientInterceptor implements RequestInterceptor {
    private static final String AUTHORIZATION_HEADER = "Authorization";
    private static final String BEARER_TOKEN_TYPE = "Bearer";
    private final OAuth2AuthorizedClientService clientService;

    public UserFeignClientInterceptor(OAuth2AuthorizedClientService clientService) {
        this.clientService = clientService;
    }

    @Override
    public void apply(RequestTemplate template) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        OAuth2AuthenticationToken oauthToken = (OAuth2AuthenticationToken) authentication;
        OAuth2AuthorizedClient client = clientService.loadAuthorizedClient(
                oauthToken.getAuthorizedClientRegistrationId(),
                oauthToken.getName());

        OAuth2AccessToken accessToken = client.getAccessToken();
        template.header(AUTHORIZATION_HEADER, String.format("%s %s", BEARER_TOKEN_TYPE, accessToken.getTokenValue()));
    }
}
----

I configured it as a `RequestInterceptor` in `ApiGatewayApplication.java`:

[source,java]
----
@Bean
public RequestInterceptor getUserFeignClientInterceptor(OAuth2AuthorizedClientService clientService) {
    return new UserFeignClientInterceptor(clientService);
}
----

And I added two properties in `api-gateway/src/main/resources/application.properties` so Feign is Spring Security-aware.

[source,properties]
----
feign.hystrix.enabled=true
hystrix.shareSecurityContext=true
----

== See Java Microservices Running with Security Enabled

Run all of the applications with `./mvnw` in separate terminal windows, or in your IDE if you prefer.

TIP: To make it simpler to run in an IDE, there is an aggregator `pom.xml` in the root directory. If you'd installed https://emmanuelbernard.com/blog/2017/02/27/start-intellij-idea-command-line/[]IntelliJ IDEA's command line launcher], you just need to run:

[source,shell]
----
idea pom.xml
----

Navigate to `http://localhost:8080/cool-cars` and you'll be redirected to Okta to log in.

image::{% asset_path 'blog/java-microservices/okta-login.png' %}[alt=Okta Login,width=800,align=center]

Enter the username and password for your Okta developer account and you should see a list of cool cars.

image::{% asset_path 'blog/java-microservices/cool-cars.png' %}[alt=Cool Cars,width=800,align=center]

If you made it this far, and got the examples apps running, congratulations! You're super cool! ðŸ˜Ž

One of the things you might've noticed in this example is you had to configure the OIDC properties in each application. This could be a real pain if you had 100 microservices. Yes, you could define them as environment variables and this would solve the problem. However, if you have different microservices stacks using different OIDC apps, this won't work.

https://spring.io/projects/spring-cloud-config[Spring Cloud Config] is a project that provides externalized configuration for distributed systems. Rather than adding it to this example, I've got a much more hip way to demo it.

== Use JHipster to Generate a Java Microservices Architecture with OAuth 2.0

https://www.jhipster.tech/[]JHipster] is a development platform to generate, develop, and deploy Spring Boot + ( Angular || React || Vue ) applications. In addition, it supports creating Spring-based microservice architectures. In fact, if you create microservices projects with "OAuth 2.0 / OIDC" for authentication, you'll be using code that's very similar to the example above.

To use JHipster, you'll need to have https://nodejs.org[Node.js] installed. You can also use https://start.jhipster.tech[start.jhipster.tech], which is similar to start.spring.io.

The most common way to install JHipster is using npm:

[source,shell]
----
npm install -g generator-jhipster@6.0.1
----

NOTE: You can run the command above without the version number to get the lastest version of JHipster. If it's 6.x, this tutorial _should_ work, but I can't guarantee it does.

In a terminal, create a directory to hold all the projects you're about to create. For example, `jhipster`.

Create an `apps.jh` file in this directory and put the following code into it.

[source,json]
----
application {
  config {
    baseName gateway,
    packageName com.okta.developer.gateway,
    applicationType gateway,
    authenticationType oauth2,
    prodDatabaseType postgresql,
    serviceDiscoveryType eureka,
    testFrameworks [protractor]
  }
  entities Blog, Post, Tag, Product
}

application {
  config {
    baseName blog,
    packageName com.okta.developer.blog,
    applicationType microservice,
    authenticationType oauth2,
    prodDatabaseType postgresql,
    serverPort 8081,
    serviceDiscoveryType eureka
  }
  entities Blog, Post, Tag
}

application {
  config {
    baseName store,
    packageName com.okta.developer.store,
    applicationType microservice,
    authenticationType oauth2,
    databaseType mongodb,
    devDatabaseType mongodb,
    prodDatabaseType mongodb,
    enableHibernateCache false,
    serverPort 8082,
    serviceDiscoveryType eureka
  }
  entities Product
}

entity Blog {
  name String required minlength(3),
  handle String required minlength(2)
}

entity Post {
  title String required,
  content TextBlob required,
  date Instant required
}

entity Tag {
  name String required minlength(2)
}

entity Product {
  title String required,
  price BigDecimal required min(0),
  image ImageBlob
}

relationship ManyToOne {
  Blog{user(login)} to User,
  Post{blog(name)} to Blog
}

relationship ManyToMany {
  Post{tag(name)} to Tag{post}
}

paginate Post, Tag with infinite-scroll
paginate Product with pagination

microservice Product with store
microservice Blog, Post, Tag with blog

// will be created under 'docker-compose' folder
deployment {
  deploymentType docker-compose
  appsFolders [gateway, blog, store]
  dockerRepositoryName "jmicro"
  consoleOptions [zipkin]
}
----

TIP: You'll want to change the `dockerRepositoryName` in the JDL above to use your https://hub.docker.com/[Docker Hub] username if you want to publish your containers.

This code is JDL (JHipster Domain Language) and you can use it to define your app, its entities, and even deployment settings. You can learn more about JDL in https://www.jhipster.tech/jdl/[JHipster's documentation]. Below is a screenshot of JDL Studio, which can be used to edit JDL and see how entities related to each other.

image::{% asset_path 'blog/java-microservices/jdl-studio.png' %}[alt=JDL Studio,width=800,align=center]

The JDL you just put in `apps.jh` defines three applications:

* **gateway**: a single entry point to your microservices, that will include the UI components.
* **blog**: a Blog service that talks to PostgreSQL.
* **store**: a Store service that uses MongoDB.

Run the following command to create these projects in your `apps` folder.

[source,shell]
----
jhipster import-jdl apps.jh
----

This will create all three projects in parallel. You can watch the console recording below to see how it looks. The time it takes to create everything will depend on how fast your computer and internet are.

++++
<div style="text-align: center">
<script id="asciicast-246951" src="https://asciinema.org/a/246951.js" async></script>
</div>
++++

=== Create Docker Images for Microservice Apps

When the configuration is generated for Docker Compose, a warning is spit out to the console.

[source,shell]
----
WARNING! Docker Compose configuration generated, but no Jib cache found
If you forgot to generate the Docker image for this application, please run:
To generate the missing Docker image(s), please run:
  ./mvnw -Pprod verify jib:dockerBuild in /Users/mraible/java-microservices-examples/jhipster/gateway
  ./mvnw -Pprod verify jib:dockerBuild in /Users/mraible/java-microservices-examples/jhipster/blog
  ./mvnw -Pprod verify jib:dockerBuild in /Users/mraible/java-microservices-examples/jhipster/store
----

To make it easier to create Docker images with one command, create an aggregator `pom.xml` in the `jhipster` root directory.

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.okta.developer</groupId>
    <artifactId>jhipster-parent</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <packaging>pom</packaging>
    <name>jhipster-parent</name>
    <modules>
        <module>gateway</module>
        <module>blog</module>
        <module>store</module>
    </modules>
</project>
----

Then "just jib it" using https://github.com/GoogleContainerTools/jib[Jib].

[source,shell]
----
mvn -Pprod verify jib:dockerBuild
----

TIP: If you don't have Maven installed, use `brew install maven` on a Mac, or see https://maven.apache.org/install.html[Maven's installation docs].

You will get an error at the end (`No plugin found for prefix 'jib' in the current project`). You can ignore it.

[source,shell]
----
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO]
[INFO] Gateway 0.0.1-SNAPSHOT ............................. SUCCESS [03:00 min]
[INFO] Blog 0.0.1-SNAPSHOT ................................ SUCCESS [ 36.402 s]
[INFO] Store 0.0.1-SNAPSHOT ............................... SUCCESS [ 34.247 s]
[INFO] jhipster-parent 1.0.0-SNAPSHOT ..................... FAILURE [  0.248 s]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 04:11 min
[INFO] Finished at: 2019-05-17T07:44:29-06:00
[INFO] ------------------------------------------------------------------------
[ERROR] No plugin found for prefix 'jib' in the current project...
Execution time: 4 min. 13 s.
----

=== Run Your Java Microservices Stack with Docker Compose

Once everything has finished building, cd into the `docker-compose` directory and start all your containers.

[source,shell]
----
cd docker-compose
docker-compose up -d
----

TIP: Remove the `-d` if you want to see all the logs in your current terminal window.

It will take several minutes to start all eight of your containers. You can use https://kitematic.com/[Kitematic] to monitor their startup progress if you like.

[source,shell]
----
Creating docker-compose_gateway-app_1                ... done
Creating docker-compose_gateway-postgresql_1         ... done
Creating docker-compose_blog-app_1                   ... done
Creating docker-compose_store-mongodb_1              ... done
Creating docker-compose_keycloak_1                   ... done
Creating docker-compose_blog-postgresql_1            ... done
Creating docker-compose_jhipster-registry_1          ... done
Creating docker-compose_store-app_1                  ... done
----

=== JHipster Registry for Service Discovery with JHipster Microservices

This microservices stack uses Eureka for service discovery, just like the bare-bones Spring Boot + Spring Cloud example. This was determined by the following line for each app in the JDL.

[source,json]
----
serviceDiscoveryType eureka
----

JHipster also https://www.jhipster.tech/consul/[supports Hashicorp Consul].

When you select `eureka` for service discovery, https://github.com/jhipster/jhipster-registry[JHipster Registry] is used. This application is very similar to Eureka Server, except it has an Angular UI and includes https://spring.io/projects/spring-cloud-config[Spring Cloud Config], among other features.

Because you chose OAuth 2.0/OIDC for authentication, you'll need to create an entry in your `hosts` file (`/etc/hosts` on Linux/Mac, `C:\Windows\System32\Drivers\etc\hosts` on Windows) for Keycloak.

```
127.0.0.1	keycloak
```

This is because the Docker network recognizes `keycloak` as a registered host name, but it also redirects you to `keycloak`. Your browser is not aware of that host name without the `hosts` entry.

Open your browser and navigate to `http://localhost:8761`. You'll be redirected to Keycloak to login. Enter `admin/admin` for credentials and you'll be redirected back to JHipster Registry. You'll see all your microservice instances have been registered.

image::{% asset_path 'blog/java-microservices/jhipster-registry.png' %}[alt=JHipster Registry,width=800,align=center]

Navigate to `http://localhost:8080`, click **sign in** and you'll be logged in to the gateway. You can go to **Entities** > **Blog** and add a blog.

image::{% asset_path 'blog/java-microservices/blog-list.png' %}[alt=Blog List,width=800,align=center]

Go to **Entities** > **Product** and you can add a product too.

image::{% asset_path 'blog/java-microservices/product-list.png' %}[alt=Product List,width=800,align=center]

Pretty slick, eh?! ðŸ¤“

== Configure JHipster Microservices to Use Okta

One of the problems you saw in the bare-bones Spring Boot + Spring Cloud setup is you have to configure `okta.oauth2.*` properties in every microservice. JHipster doesn't use the Okta Spring Boot starter. It uses `spring-boot-starter-oauth2-client` and `spring-boot-starter-oauth2-resource-server` instead. The configuration for OAuth 2.0 is contained in each app's `src/main/resources/config/application.yml` file.

[source,yaml]
----
spring:
  ...
  security:
    oauth2:
      client:
        provider:
          oidc:
            issuer-uri: http://localhost:9080/auth/realms/jhipster
        registration:
          oidc:
            client-id: internal
            client-secret: internal
----

== Spring Cloud Config to the Rescue!

Rather than modifying each of your apps for Okta, you can use Spring Cloud Config in JHipster Registry to do it. Open `docker-compose/central-server-config/application.yml` and add your Okta settings.

[source,yaml]
----
spring:
  security:
    oauth2:
      client:
        provider:
          oidc:
            issuer-uri: https://{yourOktaDomain}/oauth2/default
        registration:
          oidc:
            client-id: {yourClientId}
            client-secret: {yourClientSecret}
----

The registry, gateway, blog, and store applications are all configured to read this configuration on startup.

Restart all your containers for this configuration to take effect.

[source,shell]
----
docker-compose restart
----

Before you can login, you'll need to add redirect URIs, ensure your user is in a `ROLE_ADMIN` group and users groups are included in the ID token.

Log in to your Okta dashboard, edit your OIDC app, and add the following Login redirect URIs:

* `http://localhost:8761/login/oauth2/code/oidc`
* `http://localhost:8080/login/oauth2/code/oidc`

You'll also need to add Logout redirect URIs:

* `http://localhost:8761`
* `http://localhost:8080`

Then, click **Save**.

=== Create Groups and Add Them as Claims to the ID Token

JHipster is configured by default to work with two types of users: administrators and users. Keycloak is configured with users and groups automatically, but you need to do some one-time configuration for your Okta organization.

Create a `ROLE_ADMIN` group (**Users** > **Groups** > **Add Group**) and add your user to them. Navigate to **API** > **Authorization Servers**, and click on the the `default` server. Click the **Claims** tab and **Add Claim**. Name it `groups`, and include it in the ID Token. Set the value type to `Groups` and set the filter to be a Regex of `.*`. Click **Create**.

image::{% asset_path 'blog/java-12-jhipster-6/add-claim.png' %}[alt=Add Claim,width=600,align=center]

Now when you hit `http://localhost:8761` or `http://localhost:8080`, you'll be prompted to login with Okta!

image::{% asset_path 'blog/java-microservices/jhipster-okta-login.png' %}[alt=JHipster Okta Login,width=800,align=center]

image::{% asset_path 'blog/java-microservices/jhipster-okta-success.png' %}[alt=JHipster Okta Success,width=800,align=center]

It's pretty nifty how you can configure your service registry and all your microservices in one place with Spring Cloud Config, don't you think?! ðŸ‘Œ

.Known Issues with Refresh Tokens
****
By default, Okta's access tokens expire after one hour. This is expected, and short lived access tokens are recommended when using OAuth 2.0. Refresh tokens typically live a lot longer -- think days or months -- and can be used to get new access tokens. This should happen automatically when using Okta's Spring Boot starter, but it does not.

I configured my Okta org so its access tokens expire in 5 minutes. You can do this by going to **API** > **Authorization Servers** > **Access Policies**, click on the **Default Policy**, and edit its rule. Then change the access token lifetime from 1 hour to 5 minutes.

Hit `http://localhost:8080/cool-cars` in your browser and youâ€™ll be redirected to Okta to login. Log in and you should see a JSON string of cars.

Go do something else for > 5 minutes.

Come back, refresh your browser and youâ€™ll see `[]` instead of all the cars.

I'm still working on a solution to this and will update this post once I find one. If you happen to know of a solution, please let me know!
****

== What About Kotlin?

I wrote this post with Java because it's the most popular language in the Java ecosystem. However, https://redmonk.com/sogrady/2019/03/20/language-rankings-1-19/[Kotlin is on the rise], according to RedMonk's programming language rankings from January 2019.

>  For this quarter, at least, Kotlin grew substantially while all three of its fellow JVM-based counterparts declined. Kotlin jumped so far, in fact, that it finally broke into the Top 20 at #20 and leapfrogged Clojure (#24) and Groovy (#24) while doing so. Itâ€™s still well behind Scala (#13), but Kotlinâ€™s growth has been second only to Swift in this history of these rankings so it will be interesting to see what lies ahead in the next run or two.

Spring has excellent support for Kotlin, and you can choose it as a language on start.spring.io. Heck, even JHipster has support for Kotlin with its https://github.com/jhipster/jhipster-kotlin[Kotlin Blueprint].

If you'd like to see us write more posts using Kotlin, please let us know in the comments!

== Have More Fun with Java, Spring Boot, Spring Cloud, and Microservices

I hope you liked this tour of how to build Java microservice architectures with Spring Boot and Spring Cloud. You learned how to build everything with minimal code, the configure it to be secure with Spring Security, OAuth 2.0, and Okta.

Next, you learned how JHipster makes it possible to generate the same architecture that leverages the same frameworks.

We've big fans of Spring Boot, Spring Cloud, and JHipster on this blog. Here's a few other posts you might find interesting:

* link:/blog/2019/04/01/spring-boot-microservices-with-kubernetes[Build a Microservice Architecture with Spring Boot and Kubernetes]
* link:/blog/2019/02/28/spring-microservices-docker[Build Spring Microservices and Dockerize Them for Production]
* link:/blog/2019/04/04/java-11-java-12-jhipster-oidc[Better, Faster, Lighter Java with Java 12 and JHipster 6]

Please follow us https://twitter.com/oktadev[on Twitter @oktadev] and subscribe to https://www.youtube.com/c/oktadev[our YouTube channel] for more Spring and Spring Security knowledge.
